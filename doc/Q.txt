self._exec_group.execs.grad_dict


def get_train_data(img_path, gt):
    '''
        one patch one sample one label
    :param img_path:
    :param gt:
    :return:
    '''
    img = cv2.imread(img_path)
    img_H, img_W, c = np.shape(img)

    img_bboxes = []
    xg, yg, wg, hg = gt
    for dx in np.arange(-1, 1, 0.1):
        for dy in np.arange(-1, 1, 0.1):
            for dw in np.arange(0.5, 2, 0.1):
                for dh in np.arange(0.5, 2, 0.1):
                    x = int(max(0, xg + dx * wg))
                    y = int(max(0, yg + dy * hg))
                    w = int(min(wg * dw, img_W - x))
                    h = int(min(hg * dh, img_H - y))
                    img_bboxes.append([x, y, w, h])
    img_bboxes = np.array(img_bboxes)
    rat = util.overlap_ratio(img_bboxes, gt)

    pos_img_bboxes = img_bboxes[rat > 0.7, :]
    neg_img_bboxes = img_bboxes[rat < 0.5, :]
    pos_img_bboxes = pos_img_bboxes[sample.rand_sample(np.arange(0, pos_img_bboxes.shape[0]), 500), :]
    neg_img_bboxes = neg_img_bboxes[sample.rand_sample(np.arange(0, neg_img_bboxes.shape[0]), 5000), :]

    def crop_resize_img(img_bbox, image):
        '''
            把img_bbox缩放到107,107,返回img_patch
        :param img_bbox: x,y,w,h
        :return:
        '''
        x, y, w, h = img_bbox
        img_patch = image[img_H + y:img_H + y + h, img_W + x:img_W + x + w, :]
        img_patch = imresize(img_patch, [107, 107])
        img_patch = img_patch.reshape((3, 107, 107))
        return img_patch

    pos_samples = [crop_resize_img(x, img) for x in pos_img_bboxes]
    neg_samples = [crop_resize_img(x, img) for x in neg_img_bboxes]

    return image_patches, feat_bboxes, labels